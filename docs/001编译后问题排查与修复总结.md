# app-electron 编译后问题排查与修复总结

## 问题概述

编译后的 Electron 应用在运行时出现 `ERR_FILE_NOT_FOUND` 错误，无法加载 `index.html` 文件，导致应用窗口无法正常显示。

## 问题现象

1. **错误信息**：应用启动时在终端或日志中显示 `ERR_FILE_NOT_FOUND` 错误
2. **表现**：应用窗口无法正常打开，或显示空白页面
3. **日志显示**：`dist` 目录在打包后的 `app.asar` 中不存在

## 问题原因分析

### 1. 路径配置问题

**问题**：在打包后的环境中，`__dirname` 指向 `app.asar/dist-electron` 目录，但代码中使用的相对路径 `../dist` 无法正确解析。

**原因**：

- 开发模式：`__dirname` 指向 `dist-electron` 目录，`../dist` 可以正确找到 `dist` 目录
- 打包模式：`__dirname` 指向 `app.asar/dist-electron` 目录，需要使用 `app.getAppPath()` 获取应用根路径

### 2. electron-builder 配置缺失

**问题**：`dist` 目录（渲染进程构建产物）没有被包含在打包文件中。

**原因**：

- electron-builder 默认会排除 `dist` 目录（在 `builder-debug.yml` 中可以看到 `'!dist{,/**/*}'`）
- `package.json` 中没有明确的 `build.files` 配置来包含必要的文件

## 解决方案

### 步骤 1：修复路径配置

在 `electron/main.ts` 中，根据应用是否打包来设置正确的路径：

```typescript
// 在打包后，需要使用 app.getAppPath() 来获取正确的应用路径
// 开发模式下，__dirname 指向 dist-electron 目录
// 打包后，__dirname 指向 app.asar/dist-electron 目录，而 dist 在 app.asar/dist
if (app.isPackaged) {
  // 打包后：app.getAppPath() 返回 app.asar 的路径
  process.env.DIST = path.join(app.getAppPath(), 'dist')
  process.env.VITE_PUBLIC = process.env.DIST
} else {
  // 开发模式：__dirname 指向 dist-electron 目录
  process.env.DIST = path.join(__dirname, '../dist')
  process.env.VITE_PUBLIC = path.join(__dirname, '../public')
}
```

### 步骤 2：添加日志功能

为了便于调试和排查问题，添加了完整的日志功能：

```typescript
// 日志文件路径
const logDir = app.getPath('logs')
const logFile = path.join(logDir, 'app-electron.log')

// 确保日志目录存在
if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true })
}

/**
 * 日志工具函数
 * 将日志同时输出到控制台和文件
 */
function log(level: 'info' | 'warn' | 'error' | 'debug', message: string, ...args: unknown[]) {
  const timestamp = new Date().toISOString()
  const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message} ${args.length > 0 ? JSON.stringify(args) : ''}\n`

  // 输出到控制台
  console[level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log'](
    `[${timestamp}] [${level.toUpperCase()}]`,
    message,
    ...args,
  )

  // 写入日志文件
  try {
    fs.appendFileSync(logFile, logMessage, 'utf8')
  } catch (err) {
    console.error('写入日志文件失败:', err)
  }
}

// 导出日志函数供其他模块使用
export const logger = {
  info: (message: string, ...args: unknown[]) => log('info', message, ...args),
  warn: (message: string, ...args: unknown[]) => log('warn', message, ...args),
  error: (message: string, ...args: unknown[]) => log('error', message, ...args),
  debug: (message: string, ...args: unknown[]) => log('debug', message, ...args),
}
```

### 步骤 3：添加文件存在性检查

在加载文件前检查文件是否存在，并提供详细的错误信息：

```typescript
if (VITE_DEV_SERVER_URL) {
  win.loadURL(VITE_DEV_SERVER_URL)
  logger.info('加载开发服务器', { url: VITE_DEV_SERVER_URL })
} else {
  const indexPath = path.join(process.env.DIST as string, 'index.html')
  const indexPathExists = fs.existsSync(indexPath)
  logger.info('加载本地文件', {
    path: indexPath,
    exists: indexPathExists,
    distPath: process.env.DIST,
  })

  if (!indexPathExists) {
    logger.error('index.html 文件不存在', {
      indexPath,
      distPath: process.env.DIST,
      filesInDist: fs.existsSync(process.env.DIST as string)
        ? fs.readdirSync(process.env.DIST as string)
        : 'dist 目录不存在',
    })
  }

  win.loadFile(indexPath)
}
```

### 步骤 4：配置 electron-builder

在 `package.json` 中添加 `build` 配置，明确包含必要的文件：

```json
{
  "build": {
    "appId": "com.app-electron",
    "productName": "app-electron",
    "directories": {
      "output": "dist"
    },
    "files": ["dist/**/*", "dist-electron/**/*", "package.json"],
    "mac": {
      "target": ["dmg", "zip"],
      "category": "public.app-category.utilities"
    },
    "win": {
      "target": ["nsis", "zip"]
    },
    "linux": {
      "target": ["AppImage", "deb"]
    }
  }
}
```

**关键配置说明**：

- `files`: 明确指定需要打包的文件，包括：
  - `dist/**/*`: 渲染进程构建产物（Vue 应用）
  - `dist-electron/**/*`: 主进程和预加载脚本
  - `package.json`: 应用配置信息

## 完整代码修改

### electron/main.ts 关键修改

```typescript
import { app, BrowserWindow } from 'electron'
import path from 'path'
import fs from 'fs'

// 路径配置 - 根据是否打包设置不同的路径
if (app.isPackaged) {
  process.env.DIST = path.join(app.getAppPath(), 'dist')
  process.env.VITE_PUBLIC = process.env.DIST
} else {
  process.env.DIST = path.join(__dirname, '../dist')
  process.env.VITE_PUBLIC = path.join(__dirname, '../public')
}

// 日志功能
const logDir = app.getPath('logs')
const logFile = path.join(logDir, 'app-electron.log')

if (!fs.existsSync(logDir)) {
  fs.mkdirSync(logDir, { recursive: true })
}

// ... 日志工具函数和 logger 导出 ...

// 记录应用启动信息
logger.info('应用启动', {
  isPackaged: app.isPackaged,
  version: app.getVersion(),
  platform: process.platform,
  logFile: logFile,
  appPath: app.getAppPath(),
  distPath: process.env.DIST,
  __dirname: __dirname,
})

function createWindow() {
  const preloadPath = path.join(__dirname, 'preload.js')
  logger.debug('Preload 脚本路径', { preloadPath, exists: fs.existsSync(preloadPath) })

  win = new BrowserWindow({
    icon: path.join(process.env.VITE_PUBLIC as string, 'electron-vite.svg'),
    webPreferences: {
      preload: preloadPath,
      nodeIntegration: false,
      contextIsolation: true,
    },
  })

  // 在开发模式下自动打开开发者工具
  if (!app.isPackaged || process.env.NODE_ENV === 'development') {
    win.webContents.openDevTools()
    logger.debug('开发者工具已打开')
  }

  // 监听窗口加载事件
  win.webContents.on('did-finish-load', () => {
    logger.info('窗口加载完成')
    win?.webContents.send('main-process-message', new Date().toLocaleString())
  })

  // 监听窗口错误
  win.webContents.on('did-fail-load', (_event, errorCode, errorDescription) => {
    logger.error('窗口加载失败', { errorCode, errorDescription })
  })

  // 加载页面
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL)
    logger.info('加载开发服务器', { url: VITE_DEV_SERVER_URL })
  } else {
    const indexPath = path.join(process.env.DIST as string, 'index.html')
    const indexPathExists = fs.existsSync(indexPath)
    logger.info('加载本地文件', {
      path: indexPath,
      exists: indexPathExists,
      distPath: process.env.DIST,
    })

    if (!indexPathExists) {
      logger.error('index.html 文件不存在', {
        indexPath,
        distPath: process.env.DIST,
        filesInDist: fs.existsSync(process.env.DIST as string)
          ? fs.readdirSync(process.env.DIST as string)
          : 'dist 目录不存在',
      })
    }

    win.loadFile(indexPath)
  }
}

// 监听未捕获的异常
process.on('uncaughtException', (error) => {
  logger.error('未捕获的异常', { error: error.message, stack: error.stack })
})

process.on('unhandledRejection', (reason, promise) => {
  logger.error('未处理的 Promise 拒绝', { reason, promise })
})

app.whenReady().then(() => {
  logger.info('应用准备就绪')
  createWindow()
})
```

### package.json 关键修改

```json
{
  "build": {
    "appId": "com.app-electron",
    "productName": "app-electron",
    "directories": {
      "output": "dist"
    },
    "files": ["dist/**/*", "dist-electron/**/*", "package.json"],
    "mac": {
      "target": ["dmg", "zip"],
      "category": "public.app-category.utilities"
    }
  }
}
```

## 验证方法

### 1. 重新构建应用

```bash
# 清理旧的构建
rm -rf dist dist-electron

# 重新构建
pnpm run build:mac
```

### 2. 运行应用并查看日志

```bash
# 方法 1: 使用运行脚本
./run-app.sh

# 方法 2: 直接运行可执行文件
/Applications/app-electron.app/Contents/MacOS/app-electron
```

### 3. 查看日志文件

```bash
# 查看完整日志
cat ~/Library/Logs/app-electron/app-electron.log

# 实时查看日志
tail -f ~/Library/Logs/app-electron/app-electron.log

# 查看最后 50 行
tail -n 50 ~/Library/Logs/app-electron/app-electron.log
```

### 4. 验证打包内容

检查 `app.asar` 中是否包含 `dist` 目录：

```bash
# 查看 app.asar 内容（需要先安装 asar）
npx asar list /Applications/app-electron.app/Contents/Resources/app.asar
```

应该能看到 `dist` 目录及其内容。

## 查看日志的方法

### 方法 1：查看日志文件（推荐）

日志文件位置：`~/Library/Logs/app-electron/app-electron.log`

```bash
# 实时查看日志
tail -f ~/Library/Logs/app-electron/app-electron.log

# 查看最后 100 行
tail -n 100 ~/Library/Logs/app-electron/app-electron.log
```

### 方法 2：使用 macOS 系统日志工具

```bash
# 实时查看日志流
log stream --predicate 'process == "app-electron"' --level debug

# 查看最近 1 小时的日志
log show --predicate 'process == "app-electron"' --last 1h
```

### 方法 3：在终端运行应用

```bash
# 直接运行可执行文件，查看控制台输出
/Applications/app-electron.app/Contents/MacOS/app-electron
```

## 总结

### 问题根源

1. **路径配置错误**：打包后使用相对路径 `../dist` 无法正确解析
2. **打包配置缺失**：electron-builder 默认排除 `dist` 目录，导致渲染进程文件未被打包

### 解决方案

1. **修复路径配置**：使用 `app.getAppPath()` 在打包环境中获取正确路径
2. **添加日志功能**：便于调试和问题排查
3. **配置 electron-builder**：明确包含 `dist` 目录到打包文件中
4. **添加错误检查**：在加载文件前检查文件是否存在

### 预防措施

1. 在开发时测试打包后的应用
2. 使用日志功能记录关键操作和错误
3. 明确配置 electron-builder 的 `files` 选项
4. 在代码中添加文件存在性检查

## 相关文件

- `electron/main.ts` - 主进程代码，包含路径配置和日志功能
- `package.json` - electron-builder 配置
- `run-app.sh` - 应用运行脚本
- `~/Library/Logs/app-electron/app-electron.log` - 日志文件

## 参考资源

- [Electron 应用打包文档](https://www.electronjs.org/docs/latest/tutorial/application-distribution)
- [electron-builder 配置文档](https://www.electron.build/configuration/configuration)
- [Electron 路径处理](https://www.electronjs.org/docs/latest/api/app#appgetapppath)
